<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <title>
        l Proyecto de Inteligencia Artificial - HackMD
    </title>
    <link rel="icon" type="image/png" href="https://hackmd.io/favicon.png">
    <link rel="apple-touch-icon" href="https://hackmd.io/apple-touch-icon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css" integrity="sha256-3iu9jgsy9TpTwXKb7bNQzqWekRX7pPK+2OLj3R922fo=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/octicons/3.5.0/octicons.min.css" integrity="sha256-QiWfLIsCT02Sdwkogf6YMiQlj4NE84MKkzEMkZnMGdg=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/themes/prism.min.css" integrity="sha256-vtR0hSWRc3Tb26iuN2oZHt3KRUomwTufNIf5/4oeCyg=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/github-gist.min.css" integrity="sha256-tAflq+ymku3Khs+I/WcAneIlafYgDiOQ9stIHH985Wo=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/emojify.js/1.1.0/css/basic/emojify.min.css" integrity="sha256-UOrvMOsSDSrW6szVLe8ZDZezBxh5IoIfgTwdNDgTjiU=" crossorigin="anonymous" />
    <style>
        @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400italic,600,600italic,300italic,300|Source+Serif+Pro|Source+Code+Pro:400,300,500&subset=latin,latin-ext);.markdown-body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body:after,.markdown-body:before{display:table;content:""}.markdown-body:after{clear:both}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#c00}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e7e7e7;border:0}.markdown-body blockquote{padding:0 1em;color:#777;border-left:.25em solid #ddd}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body .loweralpha{list-style-type:lower-alpha}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#000;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 code,.markdown-body h1 tt,.markdown-body h2 code,.markdown-body h2 tt,.markdown-body h3 code,.markdown-body h3 tt,.markdown-body h4 code,.markdown-body h4 tt,.markdown-body h5 code,.markdown-body h5 tt,.markdown-body h6 code,.markdown-body h6 tt{font-size:inherit}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{padding-bottom:.3em;border-bottom:1px solid #eee}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#777}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol.no-list,.markdown-body ul.no-list{padding:0;list-style-type:none}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table{display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}.markdown-body table th{font-weight:700}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #ddd}.markdown-body table tr{background-color:#fff;border-top:1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color:#f8f8f8}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #ddd}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#333}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}.markdown-body code:after,.markdown-body code:before,.markdown-body tt:after,.markdown-body tt:before{letter-spacing:-.2em;content:"\A0"}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code:after,.markdown-body pre code:before,.markdown-body pre tt:after,.markdown-body pre tt:before{content:normal}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-line-num{padding:10px 8px 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:700;background:#f8f8f8;border-top:0}.markdown-body kbd{display:inline-block;padding:3px 5px;font-size:11px;line-height:10px;color:#555;vertical-align:middle;background-color:#fcfcfc;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:3px;box-shadow:inset 0 -1px 0 #bbb}.news .alert .markdown-body blockquote{padding:0 0 0 40px;border:0 none}.activity-tab .news .alert .commits,.activity-tab .news .markdown-body blockquote{padding-left:0}.task-list-item{list-style-type:none}.task-list-item label{font-weight:400}.task-list-item.enabled label{cursor:pointer}.task-list-item+.task-list-item{margin-top:3px}.task-list-item-checkbox{float:left;margin:.31em 0 .2em -1.3em!important;vertical-align:middle;cursor:default!important}.markdown-body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:40px;padding-bottom:40px;max-width:758px;overflow:visible!important}.markdown-body pre{border:inherit!important}.markdown-body code{color:inherit!important}.markdown-body pre code .wrapper{display:-moz-inline-flex;display:-ms-inline-flex;display:-o-inline-flex;display:inline-flex}.markdown-body pre code .gutter{float:left;overflow:hidden;-webkit-user-select:none;user-select:none}.markdown-body pre code .gutter.linenumber{text-align:right;position:relative;display:inline-block;cursor:default;z-index:4;padding:0 8px 0 0;min-width:20px;box-sizing:content-box;color:#afafaf!important;border-right:3px solid #6ce26c!important}.markdown-body pre code .gutter.linenumber>span:before{content:attr(data-linenumber)}.markdown-body pre code .code{float:left;margin:0 0 0 16px}.markdown-body .gist .line-numbers{border-left:none;border-top:none;border-bottom:none}.markdown-body .gist .line-data{border:none}.markdown-body .gist table{border-spacing:0;border-collapse:inherit!important}.markdown-body code[data-gist-id]{background:none;padding:0}.markdown-body code[data-gist-id]:after,.markdown-body code[data-gist-id]:before{content:""}.markdown-body code[data-gist-id] .blob-num{border:unset}.markdown-body code[data-gist-id] table{overflow:unset;margin-bottom:unset}.markdown-body code[data-gist-id] table tr{background:unset}.markdown-body[dir=rtl] pre{direction:ltr}.markdown-body[dir=rtl] code{direction:ltr;unicode-bidi:embed}.markdown-body .alert>p{margin-bottom:0}.markdown-body pre.abc,.markdown-body pre.flow-chart,.markdown-body pre.graphviz,.markdown-body pre.mermaid,.markdown-body pre.sequence-diagram{text-align:center;background-color:inherit;border-radius:0;white-space:inherit}.markdown-body pre.abc>code,.markdown-body pre.flow-chart>code,.markdown-body pre.graphviz>code,.markdown-body pre.mermaid>code,.markdown-body pre.sequence-diagram>code{text-align:left}.markdown-body pre.abc>svg,.markdown-body pre.flow-chart>svg,.markdown-body pre.graphviz>svg,.markdown-body pre.mermaid>svg,.markdown-body pre.sequence-diagram>svg{max-width:100%;height:100%}.markdown-body pre>code.wrap{white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}.markdown-body .alert>p,.markdown-body .alert>ul{margin-bottom:0}.markdown-body summary{display:list-item}.markdown-body summary:focus{outline:none}.markdown-body details summary{cursor:pointer}.markdown-body details:not([open])>:not(summary){display:none}.markdown-body figure{margin:1em 40px}.vimeo,.youtube{cursor:pointer;display:table;text-align:center;background-position:50%;background-repeat:no-repeat;background-size:contain;background-color:#000;overflow:hidden}.vimeo,.youtube{position:relative;width:100%}.youtube{padding-bottom:56.25%}.vimeo img{width:100%;object-fit:contain;z-index:0}.youtube img{object-fit:cover;z-index:0}.vimeo iframe,.youtube iframe,.youtube img{width:100%;height:100%;position:absolute;top:0;left:0}.vimeo iframe,.youtube iframe{vertical-align:middle;z-index:1}.vimeo .icon,.youtube .icon{position:absolute;height:auto;width:auto;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;opacity:.3;transition:opacity .2s;z-index:0}.vimeo:hover .icon,.youtube:hover .icon{opacity:.6;transition:opacity .2s}.slideshare .inner,.speakerdeck .inner{position:relative;width:100%}.slideshare .inner iframe,.speakerdeck .inner iframe{position:absolute;top:0;bottom:0;left:0;right:0;width:100%;height:100%}.MJX_Assistive_MathML{display:none}.ui-infobar{position:relative;z-index:2;max-width:758px;margin-top:25px;margin-bottom:-25px;color:#777}.ui-toc{position:fixed;bottom:20px;z-index:10000}.ui-toc-label{opacity:.3;background-color:#ccc;border:none;transition:opacity .2s}.ui-toc .open .ui-toc-label{opacity:1;color:#fff;transition:opacity .2s}.ui-toc-label:focus{opacity:.3;background-color:#ccc;color:#000}.ui-toc-label:hover{opacity:1;background-color:#ccc;transition:opacity .2s}.ui-toc-dropdown{margin-top:23px;margin-bottom:20px;padding-left:10px;padding-right:10px;max-width:45vw;width:25vw;max-height:70vh;overflow:auto;text-align:inherit}.ui-toc-dropdown>.toc{max-height:calc(70vh - 100px);overflow:auto}.ui-toc-dropdown[dir=rtl] .nav{padding-right:0;letter-spacing:.0029em}.ui-toc-dropdown a{overflow:hidden;text-overflow:ellipsis;white-space:pre}.ui-toc-dropdown .nav>li>a{display:block;padding:4px 20px;font-size:13px;font-weight:500;color:#767676}.ui-toc-dropdown .nav>li:first-child:last-child > ul,.ui-toc-dropdown .toc.expand ul{display:block}.ui-toc-dropdown .nav>li>a:focus,.ui-toc-dropdown .nav>li>a:hover{padding-left:19px;color:#000;text-decoration:none;background-color:transparent;border-left:1px solid #000}.ui-toc-dropdown[dir=rtl] .nav>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav>li>a:hover{padding-right:19px;border-left:none;border-right:1px solid #000}.ui-toc-dropdown .nav>.active:focus>a,.ui-toc-dropdown .nav>.active:hover>a,.ui-toc-dropdown .nav>.active>a{padding-left:18px;font-weight:700;color:#000;background-color:transparent;border-left:2px solid #000}.ui-toc-dropdown[dir=rtl] .nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav>.active>a{padding-right:18px;border-left:none;border-right:2px solid #000}.ui-toc-dropdown .nav .nav{display:none;padding-bottom:10px}.ui-toc-dropdown .nav>.active>ul{display:block}.ui-toc-dropdown .nav .nav>li>a{padding-top:1px;padding-bottom:1px;padding-left:30px;font-size:12px;font-weight:400}.ui-toc-dropdown[dir=rtl] .nav .nav>li>a{padding-right:30px}.ui-toc-dropdown .nav .nav>li>ul>li>a{padding-top:1px;padding-bottom:1px;padding-left:40px;font-size:12px;font-weight:400}.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a{padding-right:40px}.ui-toc-dropdown .nav .nav>li>a:focus,.ui-toc-dropdown .nav .nav>li>a:hover{padding-left:29px}.ui-toc-dropdown[dir=rtl] .nav .nav>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav .nav>li>a:hover{padding-right:29px}.ui-toc-dropdown .nav .nav>li>ul>li>a:focus,.ui-toc-dropdown .nav .nav>li>ul>li>a:hover{padding-left:39px}.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a:hover{padding-right:39px}.ui-toc-dropdown .nav .nav>.active:focus>a,.ui-toc-dropdown .nav .nav>.active:hover>a,.ui-toc-dropdown .nav .nav>.active>a{padding-left:28px;font-weight:500}.ui-toc-dropdown[dir=rtl] .nav .nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>a{padding-right:28px}.ui-toc-dropdown .nav .nav>.active>.nav>.active:focus>a,.ui-toc-dropdown .nav .nav>.active>.nav>.active:hover>a,.ui-toc-dropdown .nav .nav>.active>.nav>.active>a{padding-left:38px;font-weight:500}.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active>a{padding-right:38px}.markdown-body[lang^=ja]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,Hiragino Kaku Gothic Pro,\\30D2\30E9\30AE\30CE\89D2\30B4 Pro W3,Osaka,Meiryo,\\30E1\30A4\30EA\30AA,MS Gothic,"\FF2D\FF33   \30B4\30B7\30C3\30AF",sans-serif}.ui-toc-dropdown[lang^=ja]{font-family:Source Sans Pro,Helvetica,Arial,Meiryo UI,MS PGothic,"\FF2D\FF33   \FF30\30B4\30B7\30C3\30AF",sans-serif}.markdown-body[lang=zh-tw]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,PingFang TC,Microsoft JhengHei,\\5FAE\8EDF\6B63\9ED1,sans-serif}.ui-toc-dropdown[lang=zh-tw]{font-family:Source Sans Pro,Helvetica,Arial,Microsoft JhengHei UI,\\5FAE\8EDF\6B63\9ED1UI,sans-serif}.markdown-body[lang=zh-cn]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,PingFang SC,Microsoft YaHei,\\5FAE\8F6F\96C5\9ED1,sans-serif}.ui-toc-dropdown[lang=zh-cn]{font-family:Source Sans Pro,Helvetica,Arial,Microsoft YaHei UI,\\5FAE\8F6F\96C5\9ED1UI,sans-serif}.ui-affix-toc{position:fixed;top:0;max-width:15vw;max-height:70vh;overflow:auto}.back-to-top,.expand-toggle,.go-to-bottom{display:block;padding:4px 10px;margin-top:10px;margin-left:10px;font-size:12px;font-weight:500;color:#999}.back-to-top:focus,.back-to-top:hover,.expand-toggle:focus,.expand-toggle:hover,.go-to-bottom:focus,.go-to-bottom:hover{color:#563d7c;text-decoration:none}.back-to-top,.go-to-bottom{margin-top:0}.ui-user-icon{width:20px;height:20px;display:block;border-radius:3px;margin-top:2px;margin-bottom:2px;margin-right:5px;background-position:50%;background-repeat:no-repeat;background-size:contain}.ui-user-icon.small{width:18px;height:18px;display:inline-block;vertical-align:middle;margin:0 0 .2em}.ui-infobar>small>span{line-height:22px}.ui-infobar>small .dropdown{display:inline-block}.ui-infobar>small .dropdown a:focus,.ui-infobar>small .dropdown a:hover{text-decoration:none}.unselectable{-moz-user-select:none;-webkit-user-select:none;-o-user-select:none;user-select:none}@media print{blockquote,div,img,pre,table{page-break-inside:avoid!important}a[href]:after{font-size:12px!important}}.markdown-body.slides{position:relative;z-index:1;color:#222}.markdown-body.slides:before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1;background-color:currentColor;box-shadow:0 0 0 50vw}.markdown-body.slides section[data-markdown]{position:relative;margin-bottom:1.5em;background-color:#fff;text-align:center}.markdown-body.slides section[data-markdown] code{text-align:left}.markdown-body.slides section[data-markdown]:before{content:"";display:block;padding-bottom:56.23%}.markdown-body.slides section[data-markdown]>div:first-child{position:absolute;top:50%;left:1em;right:1em;transform:translateY(-50%);max-height:100%;overflow:hidden}.markdown-body.slides section[data-markdown]>ul{display:inline-block}.markdown-body.slides>section>section+section:after{content:"";position:absolute;top:-1.5em;right:1em;height:1.5em;border:3px solid #777}body{font-smoothing:subpixel-antialiased!important;-webkit-font-smoothing:subpixel-antialiased!important;-moz-osx-font-smoothing:auto!important;text-shadow:0 0 1em transparent,1px 1px 1.2px rgba(0,0,0,.004);-webkit-overflow-scrolling:touch;font-family:Source Sans Pro,Helvetica,Arial,sans-serif;letter-spacing:.025em}.focus,:focus{outline:none!important}::-moz-focus-inner{border:0!important}body.modal-open{overflow-y:auto;padding-right:0!important}
    </style>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g=" crossorigin="anonymous"></script>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js" integrity="sha256-g6iAfvZp+nDQ2TdTR/VVKJf3bGro4ub5fvWSWVRi2NE=" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js" integrity="sha256-8E4Is26QH0bD52WoQpcB+R/tcWQtpzlCojrybUd7Mxo=" crossorigin="anonymous"></script>
    <![endif]-->
</head>

<body>
    <div id="doc" class="markdown-body container-fluid" style="position: relative;"><p>title: "l Proyecto de Inteligencia Artificial"<br>
author: "Adrián Álvarez - Marlon Agüero - César Borge"<br>
date: "04 de mayo del 2018"<br>
output:<br>
html_document:<br>
toc: true<br>
toc_depth: 5<br>
toc_float:<br>
collapsed: false<br>
smooth_scroll: true</p><h1 id="l-Proyecto-de-Inteligencia-Artificial"><a class="anchor hidden-xs" href="#l-Proyecto-de-Inteligencia-Artificial" title="l-Proyecto-de-Inteligencia-Artificial"><span class="octicon octicon-link"></span></a>l Proyecto de Inteligencia Artificial</h1><h5 id="Autores"><a class="anchor hidden-xs" href="#Autores" title="Autores"><span class="octicon octicon-link"></span></a>Autores:</h5><h6 id="Adrián-Álvarez---Marlon-Agüero---César-Borge"><a class="anchor hidden-xs" href="#Adrián-Álvarez---Marlon-Agüero---César-Borge" title="Adrián-Álvarez---Marlon-Agüero---César-Borge"><span class="octicon octicon-link"></span></a>Adrián Álvarez - Marlon Agüero - César Borge</h6><h4 id="Sobre-el-proyecto"><a class="anchor hidden-xs" href="#Sobre-el-proyecto" title="Sobre-el-proyecto"><span class="octicon octicon-link"></span></a>Sobre el proyecto:</h4><p>Durante el mes de febrero y abril, se realizaron en Costa Rica las elecciones presidenciales. El propósito de este proyecto fue <strong>analizar</strong> el comportamiento y los resultados de diferentes <strong>modelos de Inteligencia Artificial</strong> particularmente dentro del área de <strong>machine learning</strong>, al ser utilizados para <strong>predecir</strong> a partir de datos de votantes ficticios, para cual partido político fueron sus votos para la primera y segunda ronda de las elecciones. Para cumplir con dicho objetivo se analizaron los siguientes modelos de inteligencia artificial:</p><ul>
<li>Árboles de decisión.</li>
<li>K-Nearest Neighbors utilizando K-d Trees.</li>
<li>Regresión Logística.</li>
<li>Redes Neuronales.</li>
<li>Support Vector Machines.</li>
</ul><p>En el proyecto corto 1, el equipo de desarrollo tenía como objetivo generar datos ficticios de votantes de las elecciones presidenciales de Costa Rica, realizadas en febrero el 2018. Para ello, se tenía que tomar en cuenta datos proporcionados por el Tribunal Supremo de Elecciones, respecto a la cantidad de votos por junta y datos del Estado de la Nación, respecto a los indicadores cantonales a los que pertenecían dichas juntas.</p><p>Se le proporcionó al equipo los siguientes enlaces para obtener dicha información:</p><ul>
<li>
<p><a href="http://www.tse.go.cr/elecciones2018/actas_escrutinio.htm" target="_blank">Votos por junta</a></p>
</li>
<li>
<p><a href="http://www.tse.go.cr/pdf/nacional2018/JRV.pdf" target="_blank">Juntas por cantón</a></p>
</li>
<li>
<p><a href="https://www.estadonacion.or.cr/files/biblioteca_virtual/otras_publicaciones/Indicadores-cantonales_Censos-2000-y-2011.xlsx" target="_blank">Indicadores cantonales</a></p>
</li>
<li>
<p><a href="http://www.inec.go.cr/wwwisis/documentos/INEC/Indicadores_Demograficos_Cantonales/Indicadores_Demograficos_Cantonales_2013.pdf" target="_blank">Distribución de edades</a></p>
</li>
</ul><p>A continuación una lista de los datos tomados en cuenta de cada cantón, para generar los votantes:</p><ol>
<li>Cantidad de votos de cada partido, nulos y blancos para primera ronda.</li>
<li>Cantidad de votos de cada partido, nulos y blancos para segunda ronda.</li>
<li>Población total.</li>
<li>Superficie.</li>
<li>Densidad de población.</li>
<li>Porcentaje de población urbana.</li>
<li>Relación hombres-mujeres.</li>
<li>Relación de dependencia demográfica.</li>
<li>Viviendas individuales ocupadas.</li>
<li>Promedio de ocupantes.</li>
<li>Porcentaje de viviendas en buen estado.</li>
<li>Porcentaje de viviendas hacinadas.</li>
<li>Porcentaje de alfabetismo.</li>
<li>Escolaridad promedio.</li>
<li>Porcentaje de asistencia a la educación regular.</li>
<li>Personas fuera de la fuerza de trabajo.</li>
<li>Tasa neta de participación en la fuerza de trabajo.</li>
<li>Porcentaje de población ocupada no asegurada.</li>
<li>Porcentaje de población nacida en el extranjero.</li>
<li>Porcentaje de población con discapacidad.</li>
<li>Porcentaje de población no asegurada.</li>
<li>Porcentaje de hogares con jefatura femenina</li>
<li>Porcentaje de hogares con jefatura compartida.</li>
<li>Cantidad de personas mayores a 18 años en el país.</li>
<li>Cantidad de personas mayores a 65 años en el país.</li>
</ol><p>Por su parte cada votante fue generado con los siguientes datos:</p><table>
<thead>
<tr>
<th>Dato</th>
<th>Valores posibles</th>
<th>Criterio de asignación</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cantón</td>
<td>Cualquiera de los cantones del país</td>
<td>La probabilidad de asignación se basó en la cantidad de votos de cada cantón.</td>
</tr>
<tr>
<td>Género</td>
<td>M, F</td>
<td>La probabilidad de asignación se basó en el índice de hombres-mujer de cada cantón.</td>
</tr>
<tr>
<td>Edad</td>
<td>18 - 105</td>
<td>La probabilidad de asignación se basó en la distribución de edades según el INEC.</td>
</tr>
<tr>
<td>Zona</td>
<td>Urbana, Rural</td>
<td>La probabilidad de asignación se basó en el índice de población urbana de cada cantón.</td>
</tr>
<tr>
<td>Dependiente</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de relación de dependencia demográfica de cada cantón, tomando en cuenta también la edad generada.</td>
</tr>
<tr>
<td>Casa en buen estado</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de viviendas en buen estado de cada cantón.</td>
</tr>
<tr>
<td>Casa Hacinada</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de viviendas hacinadas de cada cantón.</td>
</tr>
<tr>
<td>Alfabeta</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de alfabetismo de cada cantón. Tomando también en cuenta la edad generada.</td>
</tr>
<tr>
<td>Promedio de escolaridad</td>
<td>Cantidad de años de escolaridad.</td>
<td>Valor estático obtenido del índice de escolaridad promedio. La asignación de este valor depende de la edad generada.</td>
</tr>
<tr>
<td>Asistencia a educación regular</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de asistencia a educación regular de cada cantón. Tomando también en cuenta la edad generada.</td>
</tr>
<tr>
<td>En la fuerza de trabajo</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de participación en la fuerza de trabajo de cada cantón. Tomando también en cuenta el género generado.</td>
</tr>
<tr>
<td>Asegurado</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de población no asegurada de cada cantón. Tomando también en cuenta el dato anterior “En la fuerza de trabajo”.</td>
</tr>
<tr>
<td>Extranjero</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de la población nacida en el extranjero de cada cantón.</td>
</tr>
<tr>
<td>Discapacitado</td>
<td>SI, NO</td>
<td>La probabilidad de asignación se basó en el índice de la población discapacitada de cada cantón.</td>
</tr>
<tr>
<td>Jefe de Hogar</td>
<td>HOMBRE, MUJER, COMPARTIDO</td>
<td>La probabilidad de asignación se basó en los índices de jefatura de hogar femenina y compartida de cada cantón.</td>
</tr>
<tr>
<td>Voto Primera Ronda</td>
<td>Cualquier partido político de las elecciones presidenciales de Costa Rica 2018, NULO, BLANCO.</td>
<td>La probabilidad de asignación se basó en la cantidad de votos de cada partido, voto nulo o voto blanco, de cada cantón para la primera ronda.</td>
</tr>
<tr>
<td>Voto Primera Ronda</td>
<td>Cualquier partido político de las elecciones presidenciales de Costa Rica 2018 en segunda ronda, NULO, BLANCO.</td>
<td>La probabilidad de asignación se basó en la cantidad de votos de cada partido, voto nulo o voto blanco, de cada cantón para la segunda ronda.</td>
</tr>
<tr>
<td>Población total (cantón)</td>
<td>Cantidad de personas.</td>
<td>Valor estático por cada cantón.</td>
</tr>
<tr>
<td>Superficie (cantón)</td>
<td>Cantidad de kilómetros cuadrados.</td>
<td>Valor estático por cada cantón.</td>
</tr>
<tr>
<td>Densidad (cantón)</td>
<td>Personas por kilómetro cuadrado</td>
<td>Valor estático por cada cantón.</td>
</tr>
<tr>
<td>Viviendas ocupadas (cantón)</td>
<td>Cantidad de viviendas.</td>
<td>Valor estático por cada cantón.</td>
</tr>
<tr>
<td>Promedio de ocupantes por vivienda (cantón)</td>
<td>Promedio de ocupantes.</td>
<td>Valor estático por cada cantón.</td>
</tr>
</tbody>
</table><p>Este generador cuenta con dos funciones:</p><ul>
<li><code>generar_muestra_pais</code>: Recibe un parámetro <code>n</code>. Genera una población de tamaño <code>n</code> tomando en cuenta todos los cantones del país.</li>
<li><code>generar_muestra_provincia</code>: Recibe un parámetro <code>n</code> y un parámetro <code>provincia</code>. Genera una población de tamaño <code>n</code> tomando en cuenta únicamente los cantones de <code>provincia</code>.</li>
</ul><p>A continuación se presenta un marco teórico que resume la teoría necesaria, con el fin de que el lector comprenda el análisis de dichos modelos.</p><h1 id="Marco-Teórico"><a class="anchor hidden-xs" href="#Marco-Teórico" title="Marco-Teórico"><span class="octicon octicon-link"></span></a>Marco Teórico</h1><h3 id="K-Nearest-Neighbors-utilizando-K-d-Trees"><a class="anchor hidden-xs" href="#K-Nearest-Neighbors-utilizando-K-d-Trees" title="K-Nearest-Neighbors-utilizando-K-d-Trees"><span class="octicon octicon-link"></span></a>K-Nearest Neighbors utilizando K-d Trees:</h3><p>La idea de <strong>K-Nearest Neighbors</strong> es que dado un ejemplo de entrada, se retornen los <code>k</code> ejemplos de entrenamiento con la menor distancia al ejemplo de entrada. El ejemplo de entrada será clasificado con la clase de mayor pluralidad entre los vecinos encontrados. Teniendo en cuenta que cada ejemplo será un vector de <code>n</code> dimensiones, la distancia entre cada ejemplo se puede calcular utilizando la fórmula de distancia euclidiana:</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5d808dc9b184ca40b14c1950be6e48c0a323a583" alt=""></p><p>En la siguiente imágen se puede apreciar un espacio de dos dimensiones donde se buscan los 3 y 6 vecinos más cercanos al punto de la estrella:</p><p><img src="http://adataanalyst.com/wp-content/uploads/2016/07/kNN-1.png" alt=""></p><p>La forma más sencilla de implementar este modelo es guardar cada uno de los ejemplos en una tabla y cuando se tenga un ejemplo de entrada, calcular la distancia con respecto a todos los ejemplos de la tabla y retornar los k ejemplos que tengan una menor distancia. Sin embargo esta solución tiene una complejidad  <code>O(n)</code>, por lo tanto cuando tenemos millones de ejemplos, se vuelve muy costosa. Para solucionar esto se utilizan los <strong>K-d Trees</strong>, en los cuales se realizan búsquedas igual que en los árboles binarios, lo cual reduce la complejidad a <code>O(log2(n))</code>.<br>
En la siguiente imagen se visualiza un K-d Tree de 3 dimensiones:</p><p><img src="https://gopalcdas.files.wordpress.com/2017/05/1.png" alt=""></p><p>Para crear un algoritmo de K-Nearest Neighbors utilizando K-d Trees desde cero, se recomienda este <a href="https://gopalcdas.com/2017/05/24/construction-of-k-d-tree-and-using-it-for-nearest-neighbour-search/" target="_blank">artículo</a>.</p><h3 id="Regresión-Logística"><a class="anchor hidden-xs" href="#Regresión-Logística" title="Regresión-Logística"><span class="octicon octicon-link"></span></a>Regresión Logística:</h3><p>Antes de entender cómo funciona una regresión logística es importante entender el significado estadístico de <code>regresión</code>. Una regresión es un proceso estadístico a través del cual se puede estimar o predecir una relación entre un conjunto de variables. Estas variables tienen una diferencia importante, se dividen en variables independientes (o también llamadas predictoras) y en variables dependientes (predicción). La <code>regresión logística</code> es un tipo especial de regresión que se utiliza para explicar y predecir una variable categórica binaria en función de un conjunto de variables independientes que a su vez pueden ser cuantitativas o categóricas. Debido al proceso matemático bajo el cual la regresión logística funciona, es crucial y beneficioso la conversión de variables categóricas a cuantitativas. También resulta conveniente ‘binarizar’ estas conversiones (categórica-&gt;cuantitativa). Otro aspecto importante por realizar para mejorar los resultados de la regresión y al mismo tiempo hacer más justa dicha regresión es normalizar (convertir un conjunto de valores que pueden tener escalas muy diferentes en una escala común) los datos. Regresión logística puede a su vez dar una clasificación no binaria, a través de un concepto llamado <code>clasificación multinomial</code> en donde la predicción se puede dar en un conjunto de clases posibles, pero sólo en una clase (excluyente). Para la implementación de cualquier tipo regresión (lineal, logística) se puede utilizar <a href="https://www.tensorflow.org/tutorials/wide" target="_blank">Tensorflow</a> un framework para hacer Machine Learning. Dicho framework fue utilizado en este proyecto.</p><h3 id="Árboles-de-decisión"><a class="anchor hidden-xs" href="#Árboles-de-decisión" title="Árboles-de-decisión"><span class="octicon octicon-link"></span></a>Árboles de decisión:</h3><p>Un <code>árbol de decisión</code> toma como entrada un objeto o una situación descrita a través de un conjunto de atributos y devuelve una decisión: el valor previsto de la salida dada la entrada. Un árbol de decisión desarrolla una secuencia de test para poder alcanzar una decisión. Cada nodo interno del árbol corresponde con un test sobre el valor de una de las propiedades, y las ramas que salen del nodo están etiquetadas con los posibles valores de dicha propiedad. Cada nodo hoja del árbol representa el valor que ha de ser devuelto si dicho nodo hoja es alcanzado. Si el árbol de decisión pretende dar una respuesta binaria (aunque puede ser categórica) el aspecto crucial para la construcción de un árbol de decisión es elegir el atributo que separe en mayor medidas las decisiones. Para ello se utiliza <code>ganancia de información</code> para obtener una medida de discriminación para seleccionar el mejor atributo para bajar de nivel en el árbol.</p><p><img src="https://www.tutorialspoint.com/data_mining/images/dm_decision_tree.jpg" alt="decisionTree"></p><h3 id="Redes-Neuronales"><a class="anchor hidden-xs" href="#Redes-Neuronales" title="Redes-Neuronales"><span class="octicon octicon-link"></span></a>Redes Neuronales:</h3><p>Desde los inicios de la Inteligencia Artificial algunos trabajos pretendían crear redes neuronales artificiales. Este modelo busca que cada neurona (nodo o unidad) tenga una función de activación y se interconecte con otras neuronas. Una neurona será activada cuando una combinación lineal en sus entradas exceda un umbral determinado por la función de activación elegida. Entre las funciones de activación se pueden encontrar la Softmax, Sigmoid, Relu. Para poder implementar una red neuronal en Python de manera sencilla y rápida se puede utilizar <a href="https://keras.io/" target="_blank">Keras</a>, que es un API a alto nivel para la creación de redes neuronales, además es el que se utilizó para realizar este proyecto. También puede seguir el siguiente <a href="https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/" target="_blank">tutorial</a> simple donde se crea una red neuronal sencilla con Keras.<br>
Nota: Los datos necesarios para la creación de las redes neuronales son los mismos utilizados por la regresión.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/RedNeuronalArtificial.png/400px-RedNeuronalArtificial.png" alt="Red Neuronal"></p><h3 id="Support-Vector-Machines"><a class="anchor hidden-xs" href="#Support-Vector-Machines" title="Support-Vector-Machines"><span class="octicon octicon-link"></span></a>Support Vector Machines:</h3><p><strong>Support Vector Machines o SVMs</strong> son un conjunto de algoritmos de aprendizaje supervisado. Se puede utilizar para problemas de clasificación (como el de este proyecto).<br>
Es decir, se pueden etiquetar una serie de datos para entrenar un SVM y así, construir un modelo que prediga la clase de una muestra de entrada.<br>
Para lograr esto SVM, representa los puntos de muestra (aquellos que se utilizaron durante el entrenamiento) en el espacio y los separa en 2 espacios por medio de un hiperplano de separación. Este hiperplano, conocido como <strong>vector soporte</strong>, es un vector entre los 2 puntos, de las 2 clases, más cercanos. Cuando se introduce una nueva muestra, con el objetivo de predecir su clase, dicha muestra se introduce en el modelo entrenado y se verifica a cual espacio pertenece.</p><p>En la siguiente imagen se presenta un caso básico de SVM:</p><p><img src="https://aitrends.com/wp-content/uploads/2018/01/1-19SVM-2.jpg" alt=""></p><p>La forma más fácil para separar ambos espacios es utilizando una línea recta, sin embargo la mayoría de problemas de clasificación presentan más de dos posibles valores de predicción o de clasificación. Para ello se utilizan las funciones <strong>Kernel</strong> que permiten mapear el espacio en un nuevo espacio de características de mayor dimensionalidad.</p><p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_iris_001.png" alt=""></p><p>Para implementar SVM en este proyecto se utilizó <a href="https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/" target="_blank">SciKit Learn</a>.</p><h3 id="Cross-Validation"><a class="anchor hidden-xs" href="#Cross-Validation" title="Cross-Validation"><span class="octicon octicon-link"></span></a>Cross-Validation:</h3><p><strong>Cross-Validation</strong> es un conjunto de algoritmos para entrenar y testear la precisión de un modelo. Para ello separa los datos a disposición en un <code>Training-Set</code> y en un <code>Test-Set</code>. En este proyecto se implementaron dos formas de Cross-Validation:</p><ol>
<li>
<p><strong>Hold-Out</strong>: Reserva un porcentaje de los datos para el <code>Test-Set</code>. Estos datos nunca son utilizados para entrenar el sistema, pero si para probarlo.</p>
</li>
<li>
<p><strong>K-Fold</strong>: Cada ejemplo de los datos es usado para entrenar y para probar. Realiza <code>k</code> iteraciones, donde en cada una se separa un conjunto de tamaño <code>1/k</code> para <code>Test-Set</code>, y el resto se usa para <code>Training-Set</code>.</p>
</li>
</ol><h1 id="Análisis-de-modelos"><a class="anchor hidden-xs" href="#Análisis-de-modelos" title="Análisis-de-modelos"><span class="octicon octicon-link"></span></a>Análisis de modelos:</h1><p>A continuación, el análisis desarrollado para cada uno de los modelos mencionados. Para cada prueba se utilizó el modelo para predecir los votos de primera ronda (<code>1R</code>), segunda ronda (<code>2R</code>) y segunda ronda tomando en cuenta el voto de primera ronda (<code>2R1R</code>) y se utilizó Hold Out Cross-Validation usando una población de 5000 votantes, separando un 25% como <strong>test-set</strong>. Excepto en las pruebas de K-Nearest Neighbors que se utilizó una población de 1000 para reducir tiempos de ejecución.</p><h3 id="Regresión-Logística1"><a class="anchor hidden-xs" href="#Regresión-Logística1" title="Regresión-Logística1"><span class="octicon octicon-link"></span></a>Regresión Logística:</h3><p>El siguiente análisis de regresión logística tuvo como objetivo evaluar un conjunto de diferentes combinaciones para la regularización <code>l1</code> y <code>l2</code>. Regularización es una técnica usada para evitar o disminuir el overfitting. Overfitting sucede cuando el modelo aprende tanto de los datos de entrenamiento que no es capaz de generalizar y responder acertadamente ante nuevos datos o casos no vistos anteriormente. A continuación se enlistan las diferentes pruebas aplicadas:</p><ol>
<li>Incremento igualitario para <code>l1</code> y <code>l2</code>:<br>
Esta prueba consiste en utilizar <code>l1=l2=0.1</code>, posteriormente <code>l1=l2=0.3</code>, <code>l1=l2=0.5</code>, <code>l1=l2=0.7</code>, <code>l1=l2=0.9</code>. Cabe mencionar que esta prueba cuenta con la particularidad que los valores de exactitud (accuracy) son un promedio de 5 ejecuciones realizadas para la misma combinación.</li>
</ol><p><img src="https://i.imgur.com/morYKLg.png" alt=""></p><p>Podemos observar una constancia de accuracy para el set de test según sea la ronda. Pero es curioso como en general predecir la segunda ronda tienen a ser más acertado que la primera, quizás por el número de clases con las que se trabajan.</p><ol start="2">
<li><code>l1=0</code> e incremento de <code>l2</code>:<br>
Esta prueba consiste en utilizar <code>l1=0</code> y <code>l2=0.1</code>, posteriormente <code>l2=0.3</code>, <code>l2=0.5</code>, <code>l2=0.7</code>, <code>l2=0.9</code> con <code>l1=0</code>. Cabe mencionar que esta prueba cuenta con la particularidad que los valores de exactitud (accuracy) son un promedio de 3 ejecuciones realizadas para la misma combinación.</li>
</ol><p><img src="https://i.imgur.com/jyCQGzh.png" alt=""></p><p>Podemos observar una constancia de accuracy para el set de test según sea la ronda. Pero es curioso como en general predecir la segunda ronda tienen a ser más acertado que la primera, quizás por el número de clases con las que se trabajan.</p><ol start="3">
<li><code>l2=0</code> e incremento de <code>l1</code>:<br>
Esta prueba consiste en utilizar <code>l2=0</code> y <code>l1=0.1</code>, posteriormente <code>l1=0.3</code>, <code>l1=0.5</code>, <code>l1=0.7</code>, <code>l1=0.9</code> con <code>l2=0</code>.Cabe mencionar que esta prueba cuenta con la particularidad que los valores de exactitud (accuracy) son un promedio de 3 ejecuciones realizadas para la misma combinación.</li>
</ol><p><img src="https://i.imgur.com/axLBjWc.png" alt=""></p><p>Podemos observar una constancia de accuracy para el set de test según sea la ronda. Pero es curioso como en general predecir la segunda ronda tienen a ser más acertado que la primera, quizás por el número de clases con las que se trabajan.</p><p>Finalmente parece crucial comparar estas tres pruebas para tomar una decisión sobre qué modificación o combinación de <code>l1</code> y <code>l2</code> utilizar para maximizar el accuracy. A continuación se muestran los resultados de cada tipo de prueba para <code>1R</code>, <code>2R``2R1R</code>.</p><p><img src="https://i.imgur.com/zFvXj6M.png" alt=""><br>
<img src="https://i.imgur.com/hJi9nWi.png" alt=""><br>
<img src="https://i.imgur.com/3pCdqY2.png" alt=""></p><p>Se puede concluir que aumentar los valores de <code>l1</code> y <code>l2</code> simultáneamente contribuye para la predicción de la primera ronda, mientras que para las segunda ronda conviene más utilizar <code>l2=0</code> y <code>l1=x</code> donde <code>x</code> puede ser el valor que más se adecue.<br>
La ejecución de este modelo podría ser como el siguiente:</p><p><code>python g01.py --regresion-logistica --holdout --porcentaje-pruebas 25 --población 5000 --l2 0.1 --l1 0.0</code></p><p>También cabe mencionar que dadas las pruebas realizadas con las variaciones de <code>l1</code> y <code>l2</code> se llegó a un máximo de 31% (trainning) y 27% (test) para primera ronda y, 64% (trainning) y 63% (test) segunda ronda. En general para este modelo, el aporte de la votación de la primera ronda para predecir la segunda tiende a ser bajo.</p><p><strong>Máximos generales</strong>:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">31.10%</td>
<td style="text-align:right">27.89%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">64.27%</td>
<td style="text-align:right">62.80%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">64.45%</td>
<td style="text-align:right">62.77%</td>
</tr>
</tbody>
</table><h3 id="Árboles-de-decisión1"><a class="anchor hidden-xs" href="#Árboles-de-decisión1" title="Árboles-de-decisión1"><span class="octicon octicon-link"></span></a>Árboles de decisión:</h3><p>El siguiente análisis de árboles de decisión tuvo como objetivo evaluar diferentes niveles de umbrales de poda para el árbol creado. La poda de un árbol tiene el objetivo de evitar el overfitting Se parte de la población anteriormente indicada al igual que el porcentaje de test set.</p><p>Al utilizar el siguiente umbral se obtiene los siguientes resultados <code>--umbral=poda=0.1</code></p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">91.37%</td>
<td style="text-align:right">18.13%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">95.01%</td>
<td style="text-align:right">52.0%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">98.41%</td>
<td style="text-align:right">53.62%</td>
</tr>
</tbody>
</table><p>Al utilizar el siguiente umbral se obtiene los siguientes resultados <code>--umbral=poda=0.3</code></p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">90.53%</td>
<td style="text-align:right">18.72%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">94.03%</td>
<td style="text-align:right">54.45%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">98.82%</td>
<td style="text-align:right">54.16%</td>
</tr>
</tbody>
</table><p>Al utilizar el siguiente umbral se obtiene los siguientes resultados <code>--umbral=poda=0.5</code></p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">89.39%</td>
<td style="text-align:right">19.84%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">91.22%</td>
<td style="text-align:right">54.66%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">98.01%</td>
<td style="text-align:right">54.53%</td>
</tr>
</tbody>
</table><p>Al utilizar el siguiente umbral se obtiene los siguientes resultados <code>--umbral=poda=0.7</code></p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">88.13%</td>
<td style="text-align:right">19.43%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">90.37%</td>
<td style="text-align:right">54.42%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">97.47%</td>
<td style="text-align:right">54.32%</td>
</tr>
</tbody>
</table><p>Al utilizar el siguiente umbral se obtiene los siguientes resultados <code>--umbral=poda=0.9</code></p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">85.26%</td>
<td style="text-align:right">20.29%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">87.03%</td>
<td style="text-align:right">55.19%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">93.60%</td>
<td style="text-align:right">53.81%</td>
</tr>
</tbody>
</table><p>Podemos notar que conforme el umbral de poda aumente el accuracy para el entrenamiento empieza a disminuir, lo cual es esperable. Por su parte el accuracy para el set de pruebas tiende a aumentar justamente porque podar el árbol hará que la generalización aumente. A continuación se muestra una comparativa que incluye solamente el accuracy de pruebas.</p><p><img src="https://i.imgur.com/zuJrnrI.png" alt=""></p><p>Se puede apreciar una importante diferencia entre la precisión para primera ronda respecto a la segunda.</p><p><strong>Máximos generales</strong>:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">91.37%</td>
<td style="text-align:right">20.29%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">95.01%</td>
<td style="text-align:right">52.20%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">98.82%</td>
<td style="text-align:right">54.53%</td>
</tr>
</tbody>
</table><p>La ejecución de este modelo podría ser dado por:<br>
<code>python g01.py --arbol --holdout --porcentaje-pruebas 25 --poblacion 5000 --umbral-poda 0.1</code></p><h3 id="K-Nearest-Neighbors-utilizando-K-d-Trees1"><a class="anchor hidden-xs" href="#K-Nearest-Neighbors-utilizando-K-d-Trees1" title="K-Nearest-Neighbors-utilizando-K-d-Trees1"><span class="octicon octicon-link"></span></a>K-Nearest Neighbors utilizando K-d Trees:</h3><p>Para este modelo el parámetro a cambiar corresponde a la cantidad de vecinos a buscar dado un ejemplo de entrada. Dicho parámetro será llamado de ahora en adelante <code>k</code>. Elegir el valor óptimo de <code>k</code> no es una tarea fácil. Normalmente se escoge un valor impar para <code>k</code>, para evitar empates a la hora de clasificar.<br>
Un valor pequeño para <code>k</code>, permitirá que el ruido de la información tenga más influencia en los resultados.<br>
Todas las pruebas para este modelo se realizaron con una población de <strong>1000</strong> votantes.<br>
A continuación los resultados al realizar una prueba utilizando el algoritmo <strong>Nearest Neighbor</strong>, que consiste en buscar un único vecino, es decir que <code>k = 1</code>.<br>
Para ejecutar esta prueba se utilizó el comando:<br>
<code>python3 g01.py --knn --k 1 --poblacion 1000 --holdout --porcentaje-pruebas 25 --prefijo pruebaKnn</code></p><p>Resultados:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">98.93</td>
<td style="text-align:right">20.0</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">99.33</td>
<td style="text-align:right">53.59</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">100.0</td>
<td style="text-align:right">49.2</td>
</tr>
</tbody>
</table><p>Como se puede apreciar en la tabla, la precisión a la hora de evaluar el modelo con el mismo set con el que fue entrenado, fuy muy alta sin embargo a la hora de evaluarlo con el test set, la precisión se redujo considerablemente. Por lo tanto se dice que el modelo no es capaz de generalizar.</p><p>Es muy importante resaltar que la predicción para la <code>1R</code> <strong>no</strong> es binaria a diferencia de <code>2R</code> y <code>2R1R</code>. Lo cual explica su baja precisión.</p><p>Otra prueba realizada fue utilizando <code>k = sqrt(N)</code> es decir <code>k = sqrt(1000)</code>.<br>
Para ejecutar esta prueba se utilizó el comando:<br>
<code>python3 g01.py --knn --k 31 --poblacion 1000 --holdout --porcentaje-pruebas 25 --prefijo pruebaKnn</code></p><p>Resultados:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">34.53</td>
<td style="text-align:right">24.0</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">62.93</td>
<td style="text-align:right">62.8</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">62.13</td>
<td style="text-align:right">58.80</td>
</tr>
</tbody>
</table><p>La precisión al evaluar el training set bajo, sin embargo al evaluar el test set la precisión subió.</p><p>Se realizaron pruebas con los siguientes <code>k</code>: 1, 31, 51, 101, 301, 501, 901. Los resultados de dichas pruebas se pueden visualizar en los siguientes gráficos.</p><p><img src="https://i.imgur.com/gzlK5QP.png" alt=""></p><p><img src="https://i.imgur.com/3FmetfT.png" alt=""></p><p>Como se aprecia en los gráficos la precisión a la hora de evaluar el test set mejora cuando el <code>k</code> es mayor a 1, pero decae al evaluar el training set. La precisión se estabiliza aunque se siga aumentando el <code>k</code>.</p><p>Como conclusión el modelo de K-Nearest Neighbors, al utilizar una muestra de 1000 votantes, nunca alcanza una precisión superior al 70%.</p><h3 id="Redes-Neuronales1"><a class="anchor hidden-xs" href="#Redes-Neuronales1" title="Redes-Neuronales1"><span class="octicon octicon-link"></span></a>Redes Neuronales:</h3><p>Las pruebas que se realizarán en las redes neuronales siempre serán con una población de 5000 y un 25% de esa población para pruebas. Los parámetros que se pueden cambiar en redes neuronales, son los que afectan la estructura como tal que serían --numero-capas y las –  --unidades-por-capa y el que afecta la función de activación de cada unidad en este caso –funcion-activacion.</p><p>Primeramente, se harán pruebas que afecten la estructura por lo que la función de activación elegida en estas pruebas será relu. Se iniciará verificando cuantas unidades por capa dan mejores resultados, en estas pruebas sólo se utilizará una capa y diferentes unidades por capa.</p><p>Promediando algunos de los resultados se obtuvo los siguientes resultados.<br>
Resultados cuando se esta usando 1 unidad por capa:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">24,91%</td>
<td style="text-align:right">25,28%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">59,56%</td>
<td style="text-align:right">58,08%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">59,56%</td>
<td style="text-align:right">58,08%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando 10 unidades por capa:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">25,87%</td>
<td style="text-align:right">25,76%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">63,74%</td>
<td style="text-align:right">61,14%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">62,81%</td>
<td style="text-align:right">61,74%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando 20 unidades por capa:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">30,34%</td>
<td style="text-align:right">26,86%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">63,23%</td>
<td style="text-align:right">62,51%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">63,81%</td>
<td style="text-align:right">62,87%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando 30 unidades por capa:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">30,70%</td>
<td style="text-align:right">26,56%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">64,25%</td>
<td style="text-align:right">61,54%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">64,51%</td>
<td style="text-align:right">60,92%</td>
</tr>
</tbody>
</table><p>Tal vez con estas tablas no se logre ver que en el caso de la precisión del test set, esta empieza a subir y cuando llega a 30 baja, por lo que es probable que un buen número para unidades por capa sea 20 o un número cercano. Esto se verá mejor en los siguientes gráficos.</p><p><img src="https://i.imgur.com/oUBAYzB.png" alt=""></p><p>Pero no hay que confundir esto con que entre más unidades por capa peor resultado, porque no es cierto, si hacemos una prueba más usando 40 unidades por capa nos daremos cuenta de la verdad.</p><p><img src="https://i.imgur.com/ycmepaZ.png" alt=""></p><p>Por lo que vemos que no sigue bajando y más bien podría empezar a subir.</p><p>Ahora nos toca probar la cantidad de capas, como el anterior usaremos relu como función de activación y usaremos 20 unidades por capa, la cantidad de muestras se mantiene igual que el porcentaje de muestras. La prueba de una capa y 20 unidades ya se realizó en las pruebas pasadas, por lo que esta vez se iniciara en 5 capas.<br>
Resultados cuando se esta usando 1 capa:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">30,34%</td>
<td style="text-align:right">26,86%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">63,23%</td>
<td style="text-align:right">62,51%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">63,81%</td>
<td style="text-align:right">62,87%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando 5 capas:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">25,27%</td>
<td style="text-align:right">25,56%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">63,31%</td>
<td style="text-align:right">61,48%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">63,05%</td>
<td style="text-align:right">61,30%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando 10 capas:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">24,41%</td>
<td style="text-align:right">25,54%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">60,91%</td>
<td style="text-align:right">59,36%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">60,97%</td>
<td style="text-align:right">59,40%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando 20 capas:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">25,29%</td>
<td style="text-align:right">25,18%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">59,61%</td>
<td style="text-align:right">59,70%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">59,61%</td>
<td style="text-align:right">59,70%</td>
</tr>
</tbody>
</table><p>Estos ejemplos parecen tener un comportamiento diferente a lo que pasaba con unidades por capa, porque en este en la precisión del test set parece que va bajando y no subiendo, por lo que se podría decir que para estos datos es mejor usar menos capas. En el gráfico también se puede apreciar cómo va decreciendo, pero no quiere decir que va a seguir bajando tan rápidamente, porque como se ve en el gráfico empieza a marcar como una asíntota con algún valor por debajo.</p><p><img src="https://i.imgur.com/eJPHz26.png" alt=""></p><p>Ahora solo quedan los ejemplos correspondientes a la función de activación, para este informe se utilizarán 3 funciones de activación, relu que ya se ha estado usando, softmax y sigmoid. Para estas pruebas se mantendrán la cantidad de población y el porcentaje para pruebas, para mantener lo que ya se ha probado, usaremos 1 capa y 20 unidades por capa.</p><p>Resultados cuando se está usando relu:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">30,34%</td>
<td style="text-align:right">26,86%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">63,23%</td>
<td style="text-align:right">62,51%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">63,81%</td>
<td style="text-align:right">62,87%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando softmax:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">24,83%</td>
<td style="text-align:right">23,70%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">59,47%</td>
<td style="text-align:right">60,76%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">59,47%</td>
<td style="text-align:right">60,76%</td>
</tr>
</tbody>
</table><p>Resultados cuando se está usando sigmoid:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">27,87%</td>
<td style="text-align:right">26,02%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">64,05%</td>
<td style="text-align:right">61,54%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">64,25%</td>
<td style="text-align:right">61,00%</td>
</tr>
</tbody>
</table><p>En este caso nos ayudaremos de 2 gráficos para ver cuál función de activación dio mejores resultados, primero comparando el training set.<br>
<img src="https://i.imgur.com/p8Jd5pJ.png" alt=""><br>
En este caso se podría decir que sigmoid muestra mejores resultados, pero claro se está usando el training set, si usamos el test set el gráfico sería el siguiente.<br>
<img src="https://i.imgur.com/X6aofv8.png" alt=""><br>
En este caso se ve claramente como el relu se muestra superior al usar el Test Set. Se debe aclarar que en este proyecto la función de activación en la capa de entrada y de salida se usa de forma predeterminada sigmoid, por ser la que dio mejores resultados en la predicción.</p><p>Por otro lado, se debe hacer una aclaración con la función de pérdida utilizada en este proyecto, en todos los ejemplos aquí mostrados se usó la función de pérdida categorical_crossentropy, esto debido a recomendaciones encontradas en la documentación de Keras, que puedes encontrar en el siguiente <a href="https://keras.io/losses/" target="_blank">link</a> al final de la página. Pero algunas personas también recomiendan binary_crossentropy por dar mejores resultados, luego de realizar algunas pruebas con el predictor, nos dimos cuenta de que, si bien mejora la precisión, la predicción no corresponde, para explicarlo mejor comparemos el mejor resultado que dio con categorical_crossentropy, con un resultado usando binary_crossentropy.</p><p>Resultados cuando se está usando el Test Set:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">categorical_crossentropy</th>
<th style="text-align:right">binary_crossentropy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">26,86%</td>
<td style="text-align:right">93,33%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">62,51%</td>
<td style="text-align:right">80,10%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">62,87%</td>
<td style="text-align:right">79,76%</td>
</tr>
</tbody>
</table><p><img src="https://i.imgur.com/XSKyq4m.png" alt=""></p><p>Resultados cuando se está usando el Training Set:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">categorical_crossentropy</th>
<th style="text-align:right">binary_crossentropy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">30,34%</td>
<td style="text-align:right">93,33%</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">63,23%</td>
<td style="text-align:right">81,54%</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">63,81%</td>
<td style="text-align:right">81,47%</td>
</tr>
</tbody>
</table><p><img src="https://i.imgur.com/8T7NIHB.png" alt=""></p><p>Donde claramente se puede ver que con binary_crossentropy da muchos mejores resultados, pero a la hora de realizar predicciones, no coinciden, es decir, si la red neuronal tiene una precisión de más del 90% debería de acertar en la mayoría de las predicciones, pero luego de probarlo nos dimos cuenta de que esto no fue así, entonces por eso se decidió utilizar categorical_crossentropy, no solo por ser la recomendación de keras, si no por ser la que presentaba resultados más congruentes tanto en precisión, como a la hora de realizar la predicción.</p><h3 id="Support-Vector-Machines1"><a class="anchor hidden-xs" href="#Support-Vector-Machines1" title="Support-Vector-Machines1"><span class="octicon octicon-link"></span></a>Support Vector Machines:</h3><p>El parámetro a cambiar en SVMs es el <code>kernel</code> a utilizar. La librería SciKit Learn, permite utilizar los siguientes <code>kernel</code>:</p><ul>
<li><code>linear</code></li>
<li><code>poly</code></li>
<li><code>rbf</code></li>
<li><code>sigmoid</code></li>
</ul><p>Además, al hacer una predicción multiclase como la de la primera ronda, hay que especificar un parámetro llamado <code>decision_function_shape</code> con valor <code>ovo</code> que corresponde a <strong>one vs one</strong>, un enfoque en el que si hay <code>n</code> clases, entonces se construyen <code>n * (n-1) / 2</code> clasificadores y cada uno se entrena con datos de dos clases.<br>
A continuación los resultados al realizar una prueba para cada uno de los diferentes <code>kernel</code>:</p><h5 id="Linear"><a class="anchor hidden-xs" href="#Linear" title="Linear"><span class="octicon octicon-link"></span></a>Linear</h5><p>Para ejecutar esta prueba se utilizó el comando:<br>
<code>python3 g01.py --svm --kernel linear --poblacion 1000 --holdout --porcentaje-pruebas 25 --prefijo pruebaSVM</code></p><p>Resultados:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">40.8</td>
<td style="text-align:right">26.4</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">64.66</td>
<td style="text-align:right">62.8</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">65.47</td>
<td style="text-align:right">64.0</td>
</tr>
</tbody>
</table><h5 id="Polynomial"><a class="anchor hidden-xs" href="#Polynomial" title="Polynomial"><span class="octicon octicon-link"></span></a>Polynomial</h5><p>Para ejecutar esta prueba se utilizó el comando:<br>
<code>python3 g01.py --svm --kernel poly --poblacion 1000 --holdout --porcentaje-pruebas 25 --prefijo pruebaSVM</code></p><p>Resultados:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">28.13</td>
<td style="text-align:right">22.79</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">60.26</td>
<td style="text-align:right">62.0</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">60.26</td>
<td style="text-align:right">62.0</td>
</tr>
</tbody>
</table><h5 id="RBF"><a class="anchor hidden-xs" href="#RBF" title="RBF"><span class="octicon octicon-link"></span></a>RBF</h5><p>Para ejecutar esta prueba se utilizó el comando:<br>
<code>python3 g01.py --svm --kernel rbf --poblacion 1000 --holdout --porcentaje-pruebas 25 --prefijo pruebaSVM</code></p><p>Resultados:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">26.93</td>
<td style="text-align:right">22.39</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">61.06</td>
<td style="text-align:right">63.6</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">61.06</td>
<td style="text-align:right">63.6</td>
</tr>
</tbody>
</table><h5 id="Sigmoid"><a class="anchor hidden-xs" href="#Sigmoid" title="Sigmoid"><span class="octicon octicon-link"></span></a>Sigmoid</h5><p>Para ejecutar esta prueba se utilizó el comando:<br>
<code>python3 g01.py --svm --kernel sigmoid --poblacion 1000 --holdout --porcentaje-pruebas 25 --prefijo pruebaSVM</code></p><p>Resultados:</p><table>
<thead>
<tr>
<th>Ronda</th>
<th style="text-align:right">Precisión Training Set</th>
<th style="text-align:right">Precisión Test Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>1R</td>
<td style="text-align:right">24.26</td>
<td style="text-align:right">18.79</td>
</tr>
<tr>
<td>2R</td>
<td style="text-align:right">60.4</td>
<td style="text-align:right">61.6</td>
</tr>
<tr>
<td>2R1R</td>
<td style="text-align:right">60.4</td>
<td style="text-align:right">61.6</td>
</tr>
</tbody>
</table><h2 id="Conclusión"><a class="anchor hidden-xs" href="#Conclusión" title="Conclusión"><span class="octicon octicon-link"></span></a>Conclusión</h2><p>Todos los modelos analizados en este proyecto, tuvieron una precisión inferior al 70%, lo cual no es para nada óptimo si se desea utilizar esta herramienta para un proyecto crítico. Entre las posibles causas para este fenomeno estan:</p><ul>
<li>Los datos tomados en cuenta para cada votante, no son determinantes para predecir el voto.</li>
<li>Los datos generados tienen ruido. Por ejemplo, dos votantes diferentes, con los mismos datos e índices, votaron por partidos distintos.</li>
<li>No se seleccionaron los parámetros óptimos para cada modelo a la hora de realizar pruebas. Por ejemplo, en el caso de K-Nearest Neighbors puede que la cantidad de votantes generados o bien el <code>k</code> ingresado como parámetro, no fuera el indicado para mejorar la precisión.</li>
</ul><p>Respecto al rendimiento de los modelos utilizados, sin duda el de peor rendimiento fue K-Nearest Neighbors utilizando K-d Trees. Las pruebas realizadas con una población de 1000 votantes, tomaban aproximadamente 5 minutos, mientras que los demás modelos duraban segundos. Por su parte el modelo de árboles de decisión siempre fue el más veloz.</p><p>La variación de la precisión a la hora de cambiar el tamaño de la población de entrenamiento fue nula para todos los modelos. Las pruebas más sencillas se realizaron con 100 votantes, y las pruebas registradas en este informe fueron con 1000 o 5000 votantes. Otras pruebas no incluidas en este reporte fueron con 50000 votantes, pero los resultados fueron muy similares a los de las pruebas que se mostraron previamente.</p><p>A nivel de implementación queda claro que frameworks como <code>TensorFlow</code>, <code>SciKit Learn</code> o <code>Keras</code> facilitan mucho la creación de modelos.</p><h1 id="Manual-de-uso"><a class="anchor hidden-xs" href="#Manual-de-uso" title="Manual-de-uso"><span class="octicon octicon-link"></span></a>Manual de uso:</h1><h2 id="Instalación-de-los-requerimientos"><a class="anchor hidden-xs" href="#Instalación-de-los-requerimientos" title="Instalación-de-los-requerimientos"><span class="octicon octicon-link"></span></a>Instalación  de los requerimientos:</h2><p>Este proyecto está desarrollado y probado en Python 3.6 con Ubuntu 17.10, es probable que funcione en otros sistemas operativos, pero en este manual se proporciona las instrucciones para Ubuntu, por otro lado, se aclara que no funciona en Python inferior a 3, por lo que primeramente se espera que ya el mismo esté instalado, si aun no lo tiene puede descargarlo de <a href="https://www.python.org/downloads/" target="_blank">aquí</a>.</p><p>Además, es necesario pip que es un sistema de gestión de paquetes, utilizado para instalar bibliotecas para Python, este cuenta con una versión compatible con Python 3, por lo que es esta la que se debe instalar.</p><p>Instalación para Ubuntu/Debian para python 3.x</p><blockquote>
<p>sudo apt-get install python3-pip</p>
</blockquote><p>Una vez instalado pip se podrán instalar todas las bibliotecas necesarias para correr el proyecto, <strong>se recomienda instalar estas bibliotecas con permisos de administrador</strong>.  Estas bibliotecas son:</p><ul>
<li>tec.ic.ia.pc1 (biblioteca para la generación de la población necesaria, para el proyecto)</li>
<li>SciPy con NumPy (para uso de arrays y compatibilidad con otras bibliotecas del proyecto)</li>
<li>scikit-learn (ayuda en la creación de SVM, también es útil con Redes neuronales y regresión logística)</li>
<li>keras (Para la creación de redes neuronales)</li>
<li>tensorflow (Utilizado en regresión lineal y en redes neuronales como backend).</li>
<li>Pandas (Utilizado para la normalización discretizada de los datos)</li>
</ul><h4 id="teciciapc1"><a class="anchor hidden-xs" href="#teciciapc1" title="teciciapc1"><span class="octicon octicon-link"></span></a>tec.ic.ia.pc1</h4><p>Esta biblioteca también fue creada por nosotros y también está en este mismo repositorio, pero se debe instalar por medio de pip, para su correcto funcionamiento en el proyecto, para esto se deben seguir las siguientes instrucciones.</p><ol>
<li>Se espera que ya se tenga clonado este repositorio</li>
<li>Se debe ubicar dentro de la carpeta src.</li>
<li>Se debe abrir una terminal en esta carpeta.</li>
<li>Se ejecutará el siguiente comando:</li>
</ol><blockquote>
<p>pip3 install -e .  --ignore-installed</p>
</blockquote><p>En la consola debería aparecer un mensaje que dice “Successfully installed tec”</p><h4 id="SciPy-con-NumPy"><a class="anchor hidden-xs" href="#SciPy-con-NumPy" title="SciPy-con-NumPy"><span class="octicon octicon-link"></span></a><a href="https://www.scipy.org/" target="_blank">SciPy con NumPy</a></h4><p>Primero se instalará SciPy, ésta comúnmente incluye a NumPy, pero para estar seguros también se instalará NumPy, para esto desde cualquier localización se necesita abrir una terminal y en ella escribir lo siguiente:</p><p>Para SciPy</p><blockquote>
<p>pip3 install scipy</p>
</blockquote><p>Para NumPy</p><blockquote>
<p>pip3 install numpy</p>
</blockquote><h4 id="Scikit-learn"><a class="anchor hidden-xs" href="#Scikit-learn" title="Scikit-learn"><span class="octicon octicon-link"></span></a><a href="http://scikit-learn.org/stable/install.html" target="_blank">Scikit-learn</a></h4><p>Esta biblioteca tiene algunos requisitos, pero sí ha seguido el manual no debería de preocuparse, porque los requisitos son NumPy en una versión superior o igual a 1.8.2 y SciPy en una versión superior o igual a 0.13.3. Para instalar Scikit se debe escribir el siguiente comando en una terminal:</p><blockquote>
<p>pip3 install -U scikit-learn</p>
</blockquote><h4 id="Keras"><a class="anchor hidden-xs" href="#Keras" title="Keras"><span class="octicon octicon-link"></span></a><a href="https://keras.io/" target="_blank">Keras</a></h4><p>Keras es un API de alto nivel para crear redes neuronales para instalarlo se debe abrir una terminal y escribir el siguiente comando:</p><blockquote>
<p>pip3 install -U keras</p>
</blockquote><h4 id="tensorflow"><a class="anchor hidden-xs" href="#tensorflow" title="tensorflow"><span class="octicon octicon-link"></span></a><a href="https://www.tensorflow.org/install/" target="_blank">tensorflow</a></h4><p>TensorFlow servirá de backend para ser utilizado por keras en las redes neuronales y además es utilizado por la regresión logística. Para su instalación se debe abrir una terminal y escribir lo siguiente:</p><blockquote>
<p>pip3 install -U tensorflow</p>
</blockquote><h4 id="Pandas"><a class="anchor hidden-xs" href="#Pandas" title="Pandas"><span class="octicon octicon-link"></span></a><a href="https://pandas.pydata.org/" target="_blank">Pandas</a></h4><p>En este proyecto se utilizó exclusivamente para hacer una normalización discretizada de algunos datos de nuestro set generado. Para instalarlo es necesario abrir una terminal y escribir lo siguiente:</p><blockquote>
<p>pip3 install -U pandas</p>
</blockquote><h2 id="Uso-del-sistema"><a class="anchor hidden-xs" href="#Uso-del-sistema" title="Uso-del-sistema"><span class="octicon octicon-link"></span></a>Uso del sistema</h2><p>Después de haber instalado todas las bibliotecas necesarias para el proyecto, solo queda poder usar el sistema, para esto se espera que ya está clonado este repositorio y se debe ubicar en la siguiente ruta:</p><blockquote>
<p>src/tec/ic/ia/p1</p>
</blockquote><p>una vez aquí se debe abrir una terminal o bien abrirla donde sea e ir a la ruta que ya se dio. Luego de esto se debe escribir</p><blockquote>
<p>python3 <a href="http://g01.py" target="_blank">g01.py</a></p>
</blockquote><p>pero este programa recibe varias banderas para su correcto funcionamiento y para decirle que deseas hacer, estas banderas son:</p><table>
<thead>
<tr>
<th>Bandera</th>
<th>Explicación</th>
<th>Valores Posibles</th>
</tr>
</thead>
<tbody>
<tr>
<td>- -poblacion</td>
<td>Se utiliza para seleccionar la cantidad de población, justo después de la bandera se debe escribir el número.</td>
<td>Números enteros positivo</td>
</tr>
<tr>
<td>- -porcentaje-pruebas</td>
<td>Es el porcentaje de pruebas que se guardará para la prueba final</td>
<td>Números mayor a 0 y menor a 100</td>
</tr>
<tr>
<td>- -provincia</td>
<td>Bandera que dirá que se quiere hacer el análisis por provincia</td>
<td>SAN JOSE, HEREDIA, ALAJUELA, CARTAGO, LIMON, PUNTARENAS, GUANACASTE</td>
</tr>
<tr>
<td>- -prefijo</td>
<td>Será el nombre que se le pondrá al archivo csv generado</td>
<td>Cualquier nombre</td>
</tr>
<tr>
<td>- -kfold</td>
<td>Si se escribe el programa se probara con kfold crossvalidation</td>
<td>True o False</td>
</tr>
<tr>
<td>- -kfolds</td>
<td>Son los k grupos en los que se dividirá el set de entrenamiento</td>
<td>Número entero positivo</td>
</tr>
<tr>
<td>- -holdout</td>
<td>Si se escribe el programa se probará con holdout crossvalidation</td>
<td>True o False</td>
</tr>
<tr>
<td>- -regresion-logistica</td>
<td>Activa la regresión logística</td>
<td>True o False</td>
</tr>
<tr>
<td>- -l1</td>
<td>Para seleccionar el resultado de la función de pérdida L1</td>
<td>Número entre 0 y 1.</td>
</tr>
<tr>
<td>- -l2</td>
<td>Para seleccionar el resultado de la función de pérdida L2</td>
<td>Número entre 0 y 1.</td>
</tr>
<tr>
<td>- -red-neuronal</td>
<td>Activa la red neuronal</td>
<td>True o False</td>
</tr>
<tr>
<td>- -numero-capas</td>
<td>Para seleccionar el número de capas en la red neuronal</td>
<td>Numero entero positivo</td>
</tr>
<tr>
<td>- -unidades-por-capa</td>
<td>Para seleccionar el número de unidad por capa en la red neuronal</td>
<td>Número entero positivo</td>
</tr>
<tr>
<td>- -funcion-activacion</td>
<td>Para seleccionar la función de activación en la red neuronal</td>
<td>softmax, softplus, relu, sigmoid, linear para más funciones de activación revisar el siguiente link</td>
</tr>
<tr>
<td>- -arbol</td>
<td>Activa el árbol de decisión</td>
<td>True o False</td>
</tr>
<tr>
<td>- -umbral-poda</td>
<td>Para seleccionar el umbral con el que se podara el árbol .</td>
<td>Numero entre 0 y 1.</td>
</tr>
<tr>
<td>- -knn</td>
<td>Para activar K-Nearest Neighbors</td>
<td>True o False</td>
</tr>
<tr>
<td>- -k</td>
<td>Cantidad de vecinos que tomara en cuenta, para los cálculos.</td>
<td>Número mayor que 0 y menor que el tamaño muestra.</td>
</tr>
<tr>
<td>- -svm</td>
<td>Activa Support Vector Machines</td>
<td>True o False</td>
</tr>
<tr>
<td>- -kernel</td>
<td>Para seleccionar el kernel del SVM.</td>
<td>linear, polynomial, rbf, sigmoid</td>
</tr>
</tbody>
</table><p>Una vez se entiendan estas banderas y junto al comando que se explicó antes se podrán ejecutar una red neuronal de una capa con 21 unidades por capa, con una función de activación relu, usando una población de 10000 y un 10% de pruebas, además creará un archivo csv llamado pruebaRedes de la siguiente forma:</p><blockquote>
<p>python3 <a href="http://g01.py" target="_blank">g01.py</a> --red-neuronal --numero-capas 1 --unidades-por-capa 21 --funcion-activacion relu --prefijo pruebaRedes --poblacion 10000 --porcentaje-pruebas 10 --holdout</p>
</blockquote><p>Se espera que se ejecute sólo un modelo a la vez.</p><div class="resize-sensor" style="position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; overflow: hidden; z-index: -1; visibility: hidden;"><div class="resize-sensor-expand" style="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;"><div style="position: absolute; left: 0px; top: 0px; transition: 0s; width: 100000px; height: 100000px;"></div></div><div class="resize-sensor-shrink" style="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;"><div style="position: absolute; left: 0; top: 0; transition: 0s; width: 200%; height: 200%"></div></div></div></div>
    <div class="ui-toc dropup unselectable hidden-print" style="display:none;">
        <div class="pull-right dropdown">
            <a id="tocLabel" class="ui-toc-label btn btn-default" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false" title="Table of content">
                <i class="fa fa-bars"></i>
            </a>
            <ul id="ui-toc" class="ui-toc-dropdown dropdown-menu" aria-labelledby="tocLabel">
                <div class="toc"><ul class="nav"><li class=""><a href="#l-Proyecto-de-Inteligencia-Artificial" title="l Proyecto de Inteligencia Artificial">l Proyecto de Inteligencia Artificial</a></li><li><a href="#Marco-Teórico" title="Marco Teórico">Marco Teórico</a><ul class="nav"><li><a href="#K-Nearest-Neighbors-utilizando-K-d-Trees" title="K-Nearest Neighbors utilizando K-d Trees:">K-Nearest Neighbors utilizando K-d Trees:</a></li><li><a href="#Regresión-Logística" title="Regresión Logística:">Regresión Logística:</a></li><li><a href="#Árboles-de-decisión" title="Árboles de decisión:">Árboles de decisión:</a></li><li><a href="#Redes-Neuronales" title="Redes Neuronales:">Redes Neuronales:</a></li><li><a href="#Support-Vector-Machines" title="Support Vector Machines:">Support Vector Machines:</a></li><li><a href="#Cross-Validation" title="Cross-Validation:">Cross-Validation:</a></li></ul></li><li><a href="#Análisis-de-modelos" title="Análisis de modelos:">Análisis de modelos:</a><ul class="nav"><li><a href="#Regresión-Logística1" title="Regresión Logística:">Regresión Logística:</a></li><li><a href="#Árboles-de-decisión1" title="Árboles de decisión:">Árboles de decisión:</a></li><li><a href="#K-Nearest-Neighbors-utilizando-K-d-Trees1" title="K-Nearest Neighbors utilizando K-d Trees:">K-Nearest Neighbors utilizando K-d Trees:</a></li><li><a href="#Redes-Neuronales1" title="Redes Neuronales:">Redes Neuronales:</a></li><li><a href="#Support-Vector-Machines1" title="Support Vector Machines:">Support Vector Machines:</a><ul class="nav"><li><a href="#Conclusión" title="Conclusión">Conclusión</a></li></ul></li></ul></li><li><a href="#Manual-de-uso" title="Manual de uso:">Manual de uso:</a><ul class="nav"><li><a href="#Instalación-de-los-requerimientos" title="Instalación  de los requerimientos:">Instalación  de los requerimientos:</a></li><li><a href="#Uso-del-sistema" title="Uso del sistema">Uso del sistema</a></li></ul></li></ul></div><div class="toc-menu"><a class="expand-toggle" href="#">Expand all</a><a class="back-to-top" href="#">Back to top</a><a class="go-to-bottom" href="#">Go to bottom</a></div>
            </ul>
        </div>
    </div>
    <div id="ui-toc-affix" class="ui-affix-toc ui-toc-dropdown unselectable hidden-print" data-spy="affix" style="top:17px;display:none;"  >
        <div class="toc"><ul class="nav"><li class=""><a href="#l-Proyecto-de-Inteligencia-Artificial" title="l Proyecto de Inteligencia Artificial">l Proyecto de Inteligencia Artificial</a></li><li><a href="#Marco-Teórico" title="Marco Teórico">Marco Teórico</a><ul class="nav"><li><a href="#K-Nearest-Neighbors-utilizando-K-d-Trees" title="K-Nearest Neighbors utilizando K-d Trees:">K-Nearest Neighbors utilizando K-d Trees:</a></li><li><a href="#Regresión-Logística" title="Regresión Logística:">Regresión Logística:</a></li><li><a href="#Árboles-de-decisión" title="Árboles de decisión:">Árboles de decisión:</a></li><li><a href="#Redes-Neuronales" title="Redes Neuronales:">Redes Neuronales:</a></li><li><a href="#Support-Vector-Machines" title="Support Vector Machines:">Support Vector Machines:</a></li><li><a href="#Cross-Validation" title="Cross-Validation:">Cross-Validation:</a></li></ul></li><li><a href="#Análisis-de-modelos" title="Análisis de modelos:">Análisis de modelos:</a><ul class="nav"><li><a href="#Regresión-Logística1" title="Regresión Logística:">Regresión Logística:</a></li><li><a href="#Árboles-de-decisión1" title="Árboles de decisión:">Árboles de decisión:</a></li><li><a href="#K-Nearest-Neighbors-utilizando-K-d-Trees1" title="K-Nearest Neighbors utilizando K-d Trees:">K-Nearest Neighbors utilizando K-d Trees:</a></li><li><a href="#Redes-Neuronales1" title="Redes Neuronales:">Redes Neuronales:</a></li><li><a href="#Support-Vector-Machines1" title="Support Vector Machines:">Support Vector Machines:</a><ul class="nav"><li><a href="#Conclusión" title="Conclusión">Conclusión</a></li></ul></li></ul></li><li><a href="#Manual-de-uso" title="Manual de uso:">Manual de uso:</a><ul class="nav"><li><a href="#Instalación-de-los-requerimientos" title="Instalación  de los requerimientos:">Instalación  de los requerimientos:</a></li><li><a href="#Uso-del-sistema" title="Uso del sistema">Uso del sistema</a></li></ul></li></ul></div><div class="toc-menu"><a class="expand-toggle" href="#">Expand all</a><a class="back-to-top" href="#">Back to top</a><a class="go-to-bottom" href="#">Go to bottom</a></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gist-embed/2.6.0/gist-embed.min.js" integrity="sha256-KyF2D6xPIJUW5sUDSs93vWyZm+1RzIpKCexxElmxl8g=" crossorigin="anonymous" defer></script>
    <script>
        var markdown = $(".markdown-body");
        //smooth all hash trigger scrolling
        function smoothHashScroll() {
            var hashElements = $("a[href^='#']").toArray();
            for (var i = 0; i < hashElements.length; i++) {
                var element = hashElements[i];
                var $element = $(element);
                var hash = element.hash;
                if (hash) {
                    $element.on('click', function (e) {
                        // store hash
                        var hash = this.hash;
                        if ($(hash).length <= 0) return;
                        // prevent default anchor click behavior
                        e.preventDefault();
                        // animate
                        $('body, html').stop(true, true).animate({
                            scrollTop: $(hash).offset().top
                        }, 100, "linear", function () {
                            // when done, add hash to url
                            // (default click behaviour)
                            window.location.hash = hash;
                        });
                    });
                }
            }
        }

        smoothHashScroll();
        var toc = $('.ui-toc');
        var tocAffix = $('.ui-affix-toc');
        var tocDropdown = $('.ui-toc-dropdown');
        //toc
        tocDropdown.click(function (e) {
            e.stopPropagation();
        });

        var enoughForAffixToc = true;

        function generateScrollspy() {
            $(document.body).scrollspy({
                target: ''
            });
            $(document.body).scrollspy('refresh');
            if (enoughForAffixToc) {
                toc.hide();
                tocAffix.show();
            } else {
                tocAffix.hide();
                toc.show();
            }
            $(document.body).scroll();
        }

        function windowResize() {
            //toc right
            var paddingRight = parseFloat(markdown.css('padding-right'));
            var right = ($(window).width() - (markdown.offset().left + markdown.outerWidth() - paddingRight));
            toc.css('right', right + 'px');
            //affix toc left
            var newbool;
            var rightMargin = (markdown.parent().outerWidth() - markdown.outerWidth()) / 2;
            //for ipad or wider device
            if (rightMargin >= 133) {
                newbool = true;
                var affixLeftMargin = (tocAffix.outerWidth() - tocAffix.width()) / 2;
                var left = markdown.offset().left + markdown.outerWidth() - affixLeftMargin;
                tocAffix.css('left', left + 'px');
            } else {
                newbool = false;
            }
            if (newbool != enoughForAffixToc) {
                enoughForAffixToc = newbool;
                generateScrollspy();
            }
        }
        $(window).resize(function () {
            windowResize();
        });
        $(document).ready(function () {
            windowResize();
            generateScrollspy();
        });

        //remove hash
        function removeHash() {
            window.location.hash = '';
        }

        var backtotop = $('.back-to-top');
        var gotobottom = $('.go-to-bottom');

        backtotop.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (scrollToTop)
                scrollToTop();
            removeHash();
        });
        gotobottom.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (scrollToBottom)
                scrollToBottom();
            removeHash();
        });

        var toggle = $('.expand-toggle');
        var tocExpand = false;

        checkExpandToggle();
        toggle.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            tocExpand = !tocExpand;
            checkExpandToggle();
        })

        function checkExpandToggle () {
            var toc = $('.ui-toc-dropdown .toc');
            var toggle = $('.expand-toggle');
            if (!tocExpand) {
                toc.removeClass('expand');
                toggle.text('Expand all');
            } else {
                toc.addClass('expand');
                toggle.text('Collapse all');
            }
        }

        function scrollToTop() {
            $('body, html').stop(true, true).animate({
                scrollTop: 0
            }, 100, "linear");
        }

        function scrollToBottom() {
            $('body, html').stop(true, true).animate({
                scrollTop: $(document.body)[0].scrollHeight
            }, 100, "linear");
        }
    </script>
</body>

</html>
